# Libraries --------------------------------------------------------------------

library(BSgenome.Scerevisiae.UCSC.sacCer3)
library(seqinr)
library(VariantAnnotation)
library(GenomicFeatures)
library(tidyverse)




# Definitions ------------------------------------------------------------------

# Working directory
setwd("./BE00_gRNALibraryDesign/")
getwd()


# Functions
source("code/BE00-00_Functions.R")
source("code/BE00-00_ImportExtData.R")


# Results directory
resdir <- "results/"
dir.create(resdir)


# Genome sequence (sacCer3)
sacCer3 <- BSgenome.Scerevisiae.UCSC.sacCer3
chrs    <- paste0("chr", as.roman(1:16))
sc3.set <- buildSacCer3_genome_dict(sacCer3, chrs)


# Genome annotation
txdb <- importExtData(dataset = "txdb", localfile = T) %>% print()


# Gene annotations from SGD
sgd <- importExtData(dataset = "SGD_features", localfile = T) %>%
        select(Feature_name, Standard_gene_name) %>%
        dplyr::rename(geneSys = Feature_name, 
                      gene    = Standard_gene_name) %>%
        mutate(gene = ifelse(is.na(gene), geneSys, gene)) %>%
        print()


# Provean scores for all yeast genes
# List of matrices previously generated by Joshua Bloom
proveanScores <- readRDS("../ExternalData/Provean/provean_scores.RDS")


# List of essential yeast genes
# (http://www-sequence.stanford.edu/group/yeast_deletion_project/Essential_ORFs.txt)
e_orfs <- read.delim("../ExternalData/EssentialGenes/Essential_ORFs_column.txt", stringsAsFactors = F, header = F, sep = "\t")[,1]




# Build tables of guides targeting the yeast genome ----------------------------

# Build table of all guides predicted to introduce â‰¥1 base edit
guidesWithCs.list <- list()
for(chr.name in chrs) {
        print(chr.name)
        guidesWithCs.list[[chr.name]] <- get_gRNAs_and_predict_edit(match(chr.name, chrs), 
                                                                    sacCer3, txdb, sc3.set,
                                                                    returnIdentical = FALSE)
}
guidesWithCs <- do.call("rbind", lapply(guidesWithCs.list, DataFrame))


# Build table of all guides without a C in the editing window
guidesNoCs.list <- list()
for(chr.name in chrs) {
        print(chr.name)
        guidesNoCs.list[[chr.name]] <- get_gRNAs_and_predict_edit(match(chr.name, chrs), 
                                                                     sacCer3, txdb, sc3.set, 
                                                                     returnIdentical = TRUE)
}
guidesNoCs <- do.call("rbind", lapply(guidesNoCs.list, DataFrame))


# Build table of all coding guides with extended annotation
guidesCoding.list <- list()
for(chr.name in chrs) {
        print(chr.name)
        guidesCoding.list[[chr.name]] <- predictCoding(guidesWithCs.list[[chr.name]],
                                                       subject = txdb,
                                                       seqSource = sacCer3,
                                                       varAllele = guidesWithCs.list[[chr.name]]$editedSequenceFwd,
                                                       ignore.strand = TRUE)
}
guidesCoding <- do.call("rbind", lapply(guidesCoding.list, DataFrame)) 


# Build table of all noncoding guides
guidesNonCoding <- guidesWithCs[!(guidesWithCs$guide23 %in% guidesCoding$guide23), ]


# Save intermediate files
saveRDS(guidesWithCs, paste0(resdir, "guidesWithCs.RDS"))
saveRDS(guidesNoCs, paste0(resdir, "guidesNoCs.RDS"))
saveRDS(guidesCoding, paste0(resdir, "guidesCoding.RDS"))
saveRDS(guidesNonCoding, paste0(resdir, "guidesNonCoding.RDS"))
# guidesWithCs <- readRDS(paste0(resdir, "guidesWithCs.RDS"))
# guidesNoCs  <- readRDS(paste0(resdir, "guidesNoCs.RDS"))
# guidesCoding <- readRDS(paste0(resdir, "guidesCoding.RDS"))
# guidesNonCoding <- readRDS(paste0(resdir, "guidesNonCoding.RDS"))




# Build table of 10k guides not targeting the yeast genome ---------------------

# Generate random 20-nt sequences with appropriate GC-content
set.seed(1)
randomGuides <- replicate(10988, paste0(paste(sample(c("A", "C", "G", "T"), 
                                                     size = 20, 
                                                     replace = T,
                                                     prob = c(.31,.19,.19,.31)), 
                                              collapse = ""), "NGG"))


# Count matches to the yeast genome (consider only the 12 nt upstream of PAM)
pdict_for_guide_seqs <- build_4base_pdict(randomGuides)

matches.list <- lapply(pdict_for_guide_seqs, function(seed.dict) {
        vcountPDict(seed.dict, sc3.set, max.mismatch = 0, with.indels = F)  
})
matches <- rowSums(sapply(matches.list, rowSums))

guidesNonYeast <- data.frame(guide23 = randomGuides, matches = matches)
guidesNonYeast <- guidesNonYeast[guidesNonYeast$matches == 0, ]


# Save intermediate file
saveRDS(guidesNonYeast, paste0(resdir, "guidesNonYeast.RDS"))
# guidesNonYeast <- readRDS(paste0(resdir, "guidesNonYeast.RDS"))




# Build combined guide table with additional information -----------------------

# To guidesCoding, add start and end coordinates of each CDS
transcr <- DataFrame(transcripts(txdb))
guidesCoding$TXCOORDINATES <- transcr$X[match(guidesCoding$TXID, transcr$tx_id)]


# Annotate essential ORFs
guidesCoding$essential <- guidesCoding$GENEID %in% e_orfs


# Add provean scores (takes 1-2 hours)
proveanEffects <- get_provean_scores(guidesCoding, proveanScores)
saveRDS(proveanEffects, "results/proveanEffects.RDS")
# proveanEffects <- readRDS("results/proveanEffects.RDS")
guidesCoding$provean <- proveanEffects


# Add column for absolute max value of provean effects 
guidesCoding <- get_max_absolute_provean(guidesCoding)


# Flag guides targeting regions where two genes overlap
guidesCoding$overlap <- as.vector(ifelse(sapply(guidesCoding$CDSID, length) > 1, T, F))


# Convert DFrames to tibbles, select relevant columns
guidesNonYeastTB <- as_tibble(guidesNonYeast) %>% 
        mutate(guide = str_sub(guide23, start = 1L, end = -4L),
               type = "nonYeast",
               U6   = str_detect(guide23, "TTTT"), # should have been done for guide instead of guide23
               GC   = str_count(guide, "G|C")/20) %>%
        relocate(guide) %>% print()

guidesNoCsTB <- as_tibble(guidesNoCs) %>%
        select(guide23, guide30, PAMstrand, matches, X.seqnames, X.start, X.end) %>%
        rename(chr = X.seqnames, chr.start = X.start, chr.end = X.end) %>% 
        mutate(guide = str_sub(guide23, start = 1L, end = -4L),
               type = "noCs",
               U6   = str_detect(guide23, "TTTT"), # should have been done for guide instead of guide23
               GC   = str_count(guide, "G|C")/20) %>% 
        relocate(guide) %>% print()

guidesNonCodingTB <- as_tibble(guidesNonCoding) %>%
        select(guide23, guide30, PAMstrand, matches, X.seqnames, X.start, X.end) %>%
        rename(chr = X.seqnames, chr.start = X.start, chr.end = X.end) %>% 
        mutate(guide = str_sub(guide23, start = 1L, end = -4L),
               type = "noncoding",
               U6   = str_detect(guide23, "TTTT"), # should have been done for guide instead of guide23
               GC   = str_count(guide, "G|C")/20) %>% 
        relocate(guide) %>% print()

guidesCodingTB <- as_tibble(guidesCoding) %>%
        select(guide23, guide30, PAMstrand, matches, X.seqnames, X.start, X.end,
               GENEID, CDSLOC.start, CDSLOC.end, essential, overlap,
               PROTEINLOC, REFAA, VARAA, CONSEQUENCE, provean, maxAbsProvean) %>%
        rename(chr = X.seqnames, chr.start = X.start, chr.end = X.end,
               geneSys = GENEID, gene.start = CDSLOC.start, gene.end = CDSLOC.end,
               prot.loc = PROTEINLOC, refaa = REFAA, varaa = VARAA, 
               consequence = CONSEQUENCE) %>% 
        mutate(guide   = str_sub(guide23, start = 1L, end = -4L),
               type    = "coding",
               U6      = str_detect(guide23, "TTTT"), # should have been done for guide instead of guide23
               GC      = str_count(guide, "G|C")/20,
               provean = paste(provean),
               provean = ifelse(consequence == "synonymous", NA, provean)) %>% 
        relocate(guide) %>% print()


# Specify premature stops in "consequence column" (otherwise just "nonsynonymous")
guidesCodingTB <- guidesCodingTB %>%
        mutate(consequence = if_else(str_detect(varaa, "\\*[A-Z]"), "stop", as.character(consequence)),
               consequence = as_factor(consequence)) %>% print()


# Split prot.loc column into prot.start and prot.end
guidesCodingTB <- guidesCodingTB %>%
        mutate(prot.start = ifelse(is.na(prot.loc), NA_integer_, map(prot.loc, 1)),
               prot.end   = ifelse(is.na(prot.loc), NA_integer_, map(prot.loc, 2))) %>%
        unnest(c(prot.start, prot.end), keep_empty = T) %>%
        relocate(c(prot.start, prot.end), .after = prot.loc) %>%
        select(-prot.loc) %>%
        print()


# Add individual amino acid mutations
mutations <- guideAAmutations(guide      = guidesCodingTB$guide,
                              geneSys    = guidesCodingTB$geneSys, 
                              prot.start = guidesCodingTB$prot.start, 
                              refaa      = guidesCodingTB$refaa, 
                              varaa      = guidesCodingTB$varaa) %>% print()
guidesCodingTB <- guidesCodingTB %>% full_join(mutations, by = c("guide", "geneSys", "prot.start")) %>% print()


# Add alternative gene name
guidesCodingTB <- guidesCodingTB %>% left_join(sgd, by = "geneSys") %>% print()


# Merge guide tables
guidesAll <- bind_rows(guidesNonYeastTB, guidesNoCsTB, guidesNonCodingTB, guidesCodingTB) %>% print()


# Change column order
guidesAll <- guidesAll %>%
        select(guide, guide23, guide30, PAMstrand, matches, U6, GC, 
               chr, chr.start, chr.end, geneSys, gene, gene.start, gene.end,
               essential, overlap, prot.start, prot.end, refaa, varaa,
               mut1, mut2, mut3, type, consequence, provean, maxAbsProvean) %>% print()
        

# Save final guide table
saveRDS(guidesAll, paste0(resdir, "guidesAll2.RDS"))




# Session info -----------------------------------------------------------------

writeLines(capture.output(devtools::session_info()), "code/BE00-01_SessionInfo.txt")

